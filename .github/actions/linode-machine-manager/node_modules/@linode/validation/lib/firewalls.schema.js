"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FirewallDeviceSchema = exports.UpdateFirewallSchema = exports.CreateFirewallSchema = exports.FirewallRuleSchema = exports.FirewallRuleTypeSchema = exports.validateFirewallPorts = exports.ipAddress = exports.CreateFirewallDeviceSchema = exports.validateIP = exports.IP_ERROR_MESSAGE = void 0;

var _ipaddr = require("ipaddr.js");

var _yup = require("yup");

const IP_ERROR_MESSAGE = 'Must be a valid IPv4 or IPv6 address or range.';
exports.IP_ERROR_MESSAGE = IP_ERROR_MESSAGE;

const validateIP = ipAddress => {
  // We accept plain IPs as well as ranges (i.e. CIDR notation). Ipaddr.js has separate parsing
  // methods for each, so we check for a netmask to decide the method to use.
  const [, mask] = ipAddress.split('/');

  try {
    if (mask) {
      (0, _ipaddr.parseCIDR)(ipAddress);
    } else {
      (0, _ipaddr.parse)(ipAddress);
    }
  } catch (err) {
    // Empty addresses are OK for the sake of validating the form.
    if (ipAddress !== '') {
      return false;
    }
  }

  return true;
};

exports.validateIP = validateIP;
const CreateFirewallDeviceSchema = (0, _yup.object)({
  linodes: (0, _yup.array)().of((0, _yup.number)()),
  nodebalancers: (0, _yup.array)().of((0, _yup.number)())
});
exports.CreateFirewallDeviceSchema = CreateFirewallDeviceSchema;
const ipAddress = (0, _yup.string)().test({
  name: 'validateIP',
  message: IP_ERROR_MESSAGE,
  test: validateIP
});
exports.ipAddress = ipAddress;
const validateFirewallPorts = (0, _yup.string)().matches(/^([0-9\-]+,?\s?)+$/, 'Ports must be an integer, range of integers, or a comma-separated list of integers.');
exports.validateFirewallPorts = validateFirewallPorts;
const validFirewallRuleProtocol = ['ALL', 'TCP', 'UDP', 'ICMP'];
const FirewallRuleTypeSchema = (0, _yup.object)().shape({
  action: (0, _yup.mixed)().oneOf(['ACCEPT', 'DROP']).required('Action is required'),
  protocol: (0, _yup.mixed)().oneOf(validFirewallRuleProtocol).required('Protocol is required.'),
  ports: (0, _yup.string)().when('protocol', {
    is: val => val !== 'ICMP',
    then: validateFirewallPorts,
    // Workaround to get the test to fail if ports is defined when protocol === ICMP
    otherwise: (0, _yup.string)().test({
      name: 'protocol',
      message: 'Ports are not allowed for ICMP protocols.',
      test: value => typeof value === 'undefined'
    })
  }),
  addresses: (0, _yup.object)().shape({
    ipv4: (0, _yup.array)().of(ipAddress).nullable(true),
    ipv6: (0, _yup.array)().of(ipAddress).nullable(true)
  }).strict(true).nullable(true)
});
exports.FirewallRuleTypeSchema = FirewallRuleTypeSchema;
const FirewallRuleSchema = (0, _yup.object)().shape({
  inbound: (0, _yup.array)(FirewallRuleTypeSchema).nullable(true),
  outbound: (0, _yup.array)(FirewallRuleTypeSchema).nullable(true),
  inbound_policy: (0, _yup.mixed)().oneOf(['ACCEPT', 'DROP']).required('Inbound policy is required.'),
  outbound_policy: (0, _yup.mixed)().oneOf(['ACCEPT', 'DROP']).required('Outbound policy is required.')
});
exports.FirewallRuleSchema = FirewallRuleSchema;
const CreateFirewallSchema = (0, _yup.object)().shape({
  label: (0, _yup.string)().required('Label is required.').min(3, 'Label must be between 3 and 32 characters.').max(32, 'Label must be between 3 and 32 characters.'),
  // Label validation on the back end is more complicated, we only do basic checks here.
  tags: (0, _yup.array)().of((0, _yup.string)()),
  rules: FirewallRuleSchema
});
exports.CreateFirewallSchema = CreateFirewallSchema;
const UpdateFirewallSchema = (0, _yup.object)().shape({
  label: (0, _yup.string)(),
  tags: (0, _yup.array)().of((0, _yup.string)()),
  status: (0, _yup.string)().oneOf(['enabled', 'disabled']) // 'deleted' is also a status but it's not settable

});
exports.UpdateFirewallSchema = UpdateFirewallSchema;
const FirewallDeviceSchema = (0, _yup.object)({
  type: (0, _yup.string)().oneOf(['linode', 'nodebalancer']).required('Device type is required.'),
  id: (0, _yup.number)().required('ID is required.')
});
exports.FirewallDeviceSchema = FirewallDeviceSchema;