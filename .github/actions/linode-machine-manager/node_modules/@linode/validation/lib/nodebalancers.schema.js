"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UpdateNodeBalancerSchema = exports.NodeBalancerSchema = exports.UpdateNodeBalancerConfigSchema = exports.createNodeBalancerConfigSchema = exports.nodeBalancerConfigNodeSchema = void 0;

var _yup = require("yup");

const PORT_WARNING = 'Port must be between 1 and 65535.';
const LABEL_WARNING = 'Label must be between 3 and 32 characters.';
const nodeBalancerConfigNodeSchema = (0, _yup.object)({
  label: (0, _yup.string)().matches(/^[a-zA-Z0-9.\-_]+$/, 'Label may only contain letters, numbers, periods, dashes, and underscores.').min(3, 'Label should be between 3 and 32 characters.').max(32, 'Label should be between 3 and 32 characters.').required('Label is required.'),
  address: (0, _yup.string)().matches(/^192\.168\.\d{1,3}\.\d{1,3}$/, 'Must be a valid private IPv4 address.').required('IP address is required.'),
  port: (0, _yup.number)().typeError('Port must be a number.').required('Port is required.').min(1, PORT_WARNING).max(65535, PORT_WARNING),
  weight: (0, _yup.number)().typeError('Weight must be a number.').min(1, `Weight must be between 1 and 255.`).max(255, `Weight must be between 1 and 255.`),
  mode: (0, _yup.mixed)().oneOf(['accept', 'reject', 'backup', 'drain'])
});
exports.nodeBalancerConfigNodeSchema = nodeBalancerConfigNodeSchema;
const createNodeBalancerConfigSchema = (0, _yup.object)({
  algorithm: (0, _yup.mixed)().oneOf(['roundrobin', 'leastconn', 'source']),
  check_attempts: (0, _yup.number)(),
  check_body: (0, _yup.string)().when('check', {
    is: check => check === 'http_body',
    then: (0, _yup.string)().required()
  }),
  check_interval: (0, _yup.number)().typeError('Check interval must be a number.'),
  check_passive: (0, _yup.boolean)(),
  check_path: (0, _yup.string)().matches(/\/.*/).when('check', {
    is: check => check === 'http',
    then: (0, _yup.string)().required()
  }).when('check', {
    is: check => check === 'http_body',
    then: (0, _yup.string)().required()
  }),
  proxy_protocol: (0, _yup.string)().oneOf(['none', 'v1', 'v2']),
  check_timeout: (0, _yup.number)().typeError('Timeout must be a number.').integer(),
  check: (0, _yup.mixed)().oneOf(['none', 'connection', 'http', 'http_body']),
  cipher_suite: (0, _yup.mixed)().oneOf(['recommended', 'legacy']),
  port: (0, _yup.number)().integer().required('Port is required').min(1, PORT_WARNING).max(65535, PORT_WARNING),
  protocol: (0, _yup.mixed)().oneOf(['http', 'https', 'tcp']),
  ssl_key: (0, _yup.string)().when('protocol', {
    is: protocol => protocol === 'https',
    then: (0, _yup.string)().required('SSL key is required when using HTTPS.')
  }),
  ssl_cert: (0, _yup.string)().when('protocol', {
    is: protocol => protocol === 'https',
    then: (0, _yup.string)().required('SSL certificate is required when using HTTPS.')
  }),
  stickiness: (0, _yup.mixed)().oneOf(['none', 'table', 'http_cookie']),
  nodes: (0, _yup.array)().of(nodeBalancerConfigNodeSchema).required().min(1, 'You must provide at least one back end node.')
});
exports.createNodeBalancerConfigSchema = createNodeBalancerConfigSchema;
const UpdateNodeBalancerConfigSchema = (0, _yup.object)({
  algorithm: (0, _yup.mixed)().oneOf(['roundrobin', 'leastconn', 'source']),
  check_attempts: (0, _yup.number)(),
  check_body: (0, _yup.string)().when('check', {
    is: check => check === 'http_body',
    then: (0, _yup.string)().required()
  }),
  check_interval: (0, _yup.number)().typeError('Check interval must be a number.'),
  check_passive: (0, _yup.boolean)(),
  check_path: (0, _yup.string)().matches(/\/.*/).when('check', {
    is: check => check === 'http',
    then: (0, _yup.string)().required()
  }).when('check', {
    is: check => check === 'http_body',
    then: (0, _yup.string)().required()
  }),
  proxy_protocol: (0, _yup.string)().oneOf(['none', 'v1', 'v2']),
  check_timeout: (0, _yup.number)().typeError('Timeout must be a number.').integer(),
  check: (0, _yup.mixed)().oneOf(['none', 'connection', 'http', 'http_body']),
  cipher_suite: (0, _yup.mixed)().oneOf(['recommended', 'legacy']),
  port: (0, _yup.number)().typeError('Port must be a number.').integer().min(1, PORT_WARNING).max(65535, PORT_WARNING),
  protocol: (0, _yup.mixed)().oneOf(['http', 'https', 'tcp']),
  ssl_key: (0, _yup.string)().when('protocol', {
    is: protocol => protocol === 'https',
    then: (0, _yup.string)().required()
  }),
  ssl_cert: (0, _yup.string)().when('protocol', {
    is: protocol => protocol === 'https',
    then: (0, _yup.string)().required()
  }),
  stickiness: (0, _yup.mixed)().oneOf(['none', 'table', 'http_cookie']),
  nodes: (0, _yup.array)().of(nodeBalancerConfigNodeSchema)
});
exports.UpdateNodeBalancerConfigSchema = UpdateNodeBalancerConfigSchema;
const NodeBalancerSchema = (0, _yup.object)({
  label: (0, _yup.string)().min(3, LABEL_WARNING).max(32, LABEL_WARNING).matches(/^[a-zA-Z0-9-_]+$/, "Label can't contain special characters or spaces."),
  client_conn_throttle: (0, _yup.number)().typeError('Must be a number.'),
  region: (0, _yup.string)().required('Region is required.'),
  configs: (0, _yup.array)().of(createNodeBalancerConfigSchema)
  /* @todo there must be an easier way */
  .test('unique', 'Port must be unique.', function (values) {
    if (!values) {
      return true;
    }

    const ports = [];
    const configs = values.reduce((prev, value, idx) => {
      if (!value.port) {
        return prev;
      }

      if (!ports.includes(value.port)) {
        ports.push(value.port);
        return prev;
      }

      return [...prev, idx];
    }, []);

    if (configs.length === 0) {
      return true;
    } // No ports were duplicates


    const configStrings = configs.map(config => `configs[${config}].port`);
    throw this.createError({
      path: configStrings.join('|'),
      message: 'Port must be unique.'
    });
  })
});
exports.NodeBalancerSchema = NodeBalancerSchema;
const UpdateNodeBalancerSchema = (0, _yup.object)({
  label: (0, _yup.string)().min(3, LABEL_WARNING).max(32, LABEL_WARNING).matches(/^[a-zA-Z0-9-_]+$/, "Label can't contain special characters or spaces."),
  client_conn_throttle: (0, _yup.number)().typeError('Must be a number.'),
  region: (0, _yup.string)()
});
exports.UpdateNodeBalancerSchema = UpdateNodeBalancerSchema;