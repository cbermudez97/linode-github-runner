"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CreateLinodeDiskFromImageSchema = exports.UpdateLinodeDiskSchema = exports.CreateLinodeDiskSchema = exports.UpdateLinodeConfigSchema = exports.CreateLinodeConfigSchema = exports.CreateSnapshotSchema = exports.IPAllocationSchema = exports.RebuildLinodeFromStackScriptSchema = exports.RebuildLinodeSchema = exports.UpdateLinodeSchema = exports.CreateLinodeSchema = exports.UpdateLinodePasswordSchema = exports.ResizeLinodeDiskSchema = exports.linodeInterfaceSchema = void 0;

var _yup = require("yup");

var _ipaddr = require("ipaddr.js");

const validateIP = ipAddress => {
  if (!ipAddress) {
    return true;
  } // We accept IP ranges (i.e., CIDR notation).


  try {
    (0, _ipaddr.parseCIDR)(ipAddress);
  } catch (err) {
    return false;
  }

  return true;
};

const stackscript_data = (0, _yup.array)().of((0, _yup.object)()).nullable(true);
const linodeInterfaceSchema = (0, _yup.array)().of((0, _yup.object)({
  purpose: (0, _yup.mixed)().oneOf([null, 'public', 'vlan'], 'Purpose must be null, public, or vlan.'),
  label: (0, _yup.string)().when('purpose', {
    is: value => value === 'vlan',
    then: (0, _yup.string)().required('VLAN label is required.').min(1, 'VLAN label must be between 1 and 64 characters.').max(64, 'VLAN label must be between 1 and 64 characters.').matches(/[a-zA-Z0-9-]+/, 'Must include only ASCII letters, numbers, and dashes'),
    otherwise: (0, _yup.string)().notRequired()
  }).nullable(true),
  ipam_address: (0, _yup.string)().nullable(true).test({
    name: 'validateIPAM',
    message: 'Must be a valid IPv4 range, e.g. 192.0.2.0/24.',
    test: validateIP
  })
})).test('unique-public-interface', 'Only one public interface per config is allowed.', list => {
  if (!list) {
    return true;
  }

  return list.filter(thisSlot => thisSlot.purpose === 'public').length <= 1;
}); // const rootPasswordValidation = string().test(
//   'is-strong-password',
//   'Password does not meet strength requirements.',
//   (value: string) =>
//     Boolean(value) && zxcvbn(value).score >= MINIMUM_PASSWORD_STRENGTH
// );

exports.linodeInterfaceSchema = linodeInterfaceSchema;
const ResizeLinodeDiskSchema = (0, _yup.object)({
  size: (0, _yup.number)().required('Size is required.').min(1)
});
exports.ResizeLinodeDiskSchema = ResizeLinodeDiskSchema;
const UpdateLinodePasswordSchema = (0, _yup.object)({
  password: (0, _yup.string)().required('Password is required.') // .concat(rootPasswordValidation)

});
exports.UpdateLinodePasswordSchema = UpdateLinodePasswordSchema;
const CreateLinodeSchema = (0, _yup.object)({
  type: (0, _yup.string)().ensure().required('Plan is required.'),
  region: (0, _yup.string)().ensure().required('Region is required.'),
  stackscript_id: (0, _yup.number)().notRequired(),
  backup_id: (0, _yup.number)().notRequired(),
  swap_size: (0, _yup.number)().notRequired(),
  image: (0, _yup.string)().notRequired(),
  authorized_keys: (0, _yup.array)().of((0, _yup.string)()).notRequired(),
  backups_enabled: (0, _yup.boolean)().notRequired(),
  stackscript_data,
  booted: (0, _yup.boolean)().notRequired(),
  label: (0, _yup.string)().transform(v => v === '' ? undefined : v).notRequired().min(3, 'Label must contain between 3 and 32 characters.').max(32, 'Label must contain between 3 and 32 characters.'),
  tags: (0, _yup.array)().of((0, _yup.string)()).notRequired(),
  private_ip: (0, _yup.boolean)().notRequired(),
  authorized_users: (0, _yup.array)().of((0, _yup.string)()).notRequired(),
  root_pass: (0, _yup.string)().when('image', {
    is: value => Boolean(value),
    then: (0, _yup.string)().required('You must provide a root password when deploying from an image.'),
    // .concat(rootPasswordValidation),
    otherwise: (0, _yup.string)().notRequired()
  }),
  interfaces: linodeInterfaceSchema
});
exports.CreateLinodeSchema = CreateLinodeSchema;
const alerts = (0, _yup.object)({
  cpu: (0, _yup.number)().typeError('CPU Usage must be a number').min(0, 'Must be between 0 and 4800').max(4800, 'Must be between 0 and 4800'),
  network_in: (0, _yup.number)(),
  network_out: (0, _yup.number)(),
  transfer_quota: (0, _yup.number)(),
  io: (0, _yup.number)()
}).notRequired();
const schedule = (0, _yup.object)({
  day: (0, _yup.mixed)().oneOf(['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], 'Invalid day value.'),
  window: (0, _yup.mixed)().oneOf(['W0', 'W2', 'W4', 'W6', 'W8', 'W10', 'W12', 'W14', 'W16', 'W18', 'W20', 'W22', 'W24'], 'Invalid schedule value.')
});
const backups = (0, _yup.object)({
  schedule,
  enabled: (0, _yup.boolean)()
});
const UpdateLinodeSchema = (0, _yup.object)({
  label: (0, _yup.string)().transform(v => v === '' ? undefined : v).notRequired().min(3, 'Label must contain between 3 and 32 characters.').max(32, 'Label must contain between 3 and 32 characters.'),
  tags: (0, _yup.array)().of((0, _yup.string)()).notRequired(),
  watchdog_enabled: (0, _yup.boolean)().notRequired(),
  alerts,
  backups
});
exports.UpdateLinodeSchema = UpdateLinodeSchema;
const SSHKeySchema = (0, _yup.object)({
  id: (0, _yup.number)(),
  label: (0, _yup.string)(),
  ssh_key: (0, _yup.string)(),
  created: (0, _yup.string)()
}); // Include `shape()` here so that the schema can be extended without TS complaining.

const RebuildLinodeSchema = (0, _yup.object)().shape({
  image: (0, _yup.string)().required('An image is required.'),
  root_pass: (0, _yup.string)().required('Password is required.'),
  authorized_keys: (0, _yup.array)().of(SSHKeySchema),
  authorized_users: (0, _yup.array)().of((0, _yup.string)()),
  stackscript_id: (0, _yup.number)().notRequired(),
  stackscript_data,
  booted: (0, _yup.boolean)().notRequired()
});
exports.RebuildLinodeSchema = RebuildLinodeSchema;
const RebuildLinodeFromStackScriptSchema = RebuildLinodeSchema.shape({
  stackscript_id: (0, _yup.number)().required('A StackScript is required.')
});
exports.RebuildLinodeFromStackScriptSchema = RebuildLinodeFromStackScriptSchema;
const IPAllocationSchema = (0, _yup.object)({
  type: (0, _yup.string)().required('IP address type (IPv4) is required.').oneOf(['ipv4'], 'Only IPv4 addresses can be allocated.'),
  public: (0, _yup.boolean)().required('Must specify public or private IP address.')
});
exports.IPAllocationSchema = IPAllocationSchema;
const CreateSnapshotSchema = (0, _yup.object)({
  label: (0, _yup.string)().required('A snapshot label is required.').min(1, 'Label must be between 1 and 255 characters.').max(255, 'Label must be between 1 and 255 characters.')
});
exports.CreateSnapshotSchema = CreateSnapshotSchema;
const device = (0, _yup.object)({
  disk_id: (0, _yup.number)().nullable(true),
  volume_id: (0, _yup.number)().nullable(true)
}).nullable(true);
const devices = (0, _yup.object)({
  sda: device,
  sdb: device,
  sdc: device,
  sdd: device,
  sde: device,
  sdf: device,
  sdg: device,
  sdh: device
});
const helpers = (0, _yup.object)({
  updatedb_disabled: (0, _yup.boolean)(),
  distro: (0, _yup.boolean)(),
  modules_dep: (0, _yup.boolean)(),
  network: (0, _yup.boolean)(),
  devtmpfs_automount: (0, _yup.boolean)()
});
const CreateLinodeConfigSchema = (0, _yup.object)({
  label: (0, _yup.string)().required('Label is required.').min(1, 'Label must be between 1 and 48 characters.').max(48, 'Label must be between 1 and 48 characters.'),
  devices: devices.required('A list of devices is required.'),
  kernel: (0, _yup.string)(),
  comments: (0, _yup.string)(),
  memory_limit: (0, _yup.number)(),
  run_level: (0, _yup.mixed)().oneOf(['default', 'single', 'binbash']),
  virt_mode: (0, _yup.mixed)().oneOf(['paravirt', 'fullvirt']),
  helpers,
  root_device: (0, _yup.string)(),
  interfaces: linodeInterfaceSchema
});
exports.CreateLinodeConfigSchema = CreateLinodeConfigSchema;
const UpdateLinodeConfigSchema = (0, _yup.object)({
  label: (0, _yup.string)().min(1, 'Label must be between 1 and 48 characters.').max(48, 'Label must be between 1 and 48 characters.'),
  devices,
  kernel: (0, _yup.string)(),
  comments: (0, _yup.string)(),
  memory_limit: (0, _yup.number)(),
  run_level: (0, _yup.mixed)().oneOf(['default', 'single', 'binbash']),
  virt_mode: (0, _yup.mixed)().oneOf(['paravirt', 'fullvirt']),
  helpers,
  root_device: (0, _yup.string)(),
  interfaces: linodeInterfaceSchema
});
exports.UpdateLinodeConfigSchema = UpdateLinodeConfigSchema;
const CreateLinodeDiskSchema = (0, _yup.object)({
  size: (0, _yup.number)().required('Disk size is required.'),
  label: (0, _yup.string)().required('A disk label is required.').min(1, 'Label must be between 1 and 48 characters.').max(48, 'Label must be between 1 and 48 characters.'),
  filesystem: (0, _yup.mixed)().oneOf(['raw', 'swap', 'ext3', 'ext4', 'initrd']),
  read_only: (0, _yup.boolean)(),
  image: (0, _yup.string)(),
  authorized_keys: (0, _yup.array)().of((0, _yup.string)()),
  authorized_users: (0, _yup.array)().of((0, _yup.string)()),
  root_pass: (0, _yup.string)().when('image', {
    is: value => Boolean(value),
    then: (0, _yup.string)().required('You must provide a root password when deploying from an image.'),
    // .concat(rootPasswordValidation),
    otherwise: (0, _yup.string)().notRequired()
  }),
  stackscript_id: (0, _yup.number)(),
  stackscript_data
});
exports.CreateLinodeDiskSchema = CreateLinodeDiskSchema;
const UpdateLinodeDiskSchema = (0, _yup.object)({
  label: (0, _yup.string)().notRequired().min(1, 'Label must be between 1 and 48 characters.').max(48, 'Label must be between 1 and 48 characters.'),
  filesystem: (0, _yup.mixed)().notRequired().oneOf(['raw', 'swap', 'ext3', 'ext4', 'initrd'])
});
exports.UpdateLinodeDiskSchema = UpdateLinodeDiskSchema;
const CreateLinodeDiskFromImageSchema = CreateLinodeDiskSchema.clone().shape({
  image: (0, _yup.string)().required('An image is required.')
});
exports.CreateLinodeDiskFromImageSchema = CreateLinodeDiskFromImageSchema;