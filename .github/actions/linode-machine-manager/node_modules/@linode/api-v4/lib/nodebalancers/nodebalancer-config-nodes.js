"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deleteNodeBalancerConfigNode = exports.updateNodeBalancerConfigNode = exports.createNodeBalancerConfigNode = exports.getNodeBalancerConfigNode = exports.getNodeBalancerConfigNodes = void 0;

var _nodebalancers = require("@linode/validation/lib/nodebalancers.schema");

var _constants = require("../constants");

var _request = _interopRequireWildcard(require("../request"));

var _utils = require("./utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * getNodeBalancerConfigNodes
 *
 * Returns a paginated list of nodes for the specified NodeBalancer configuration profile.
 * These are the backends that will be sent traffic for this port.
 *
 * @param nodeBalancerId { number } The ID of the NodeBalancer the config belongs to.
 * @param configId { number } The configuration profile to retrieve nodes for.
 */
const getNodeBalancerConfigNodes = (nodeBalancerId, configId) => (0, _request.default)((0, _request.setMethod)('GET'), (0, _request.setURL)(`${_constants.API_ROOT}/nodebalancers/${nodeBalancerId}/configs/${configId}/nodes`));
/**
 * getNodeBalancerConfigNode
 *
 * Returns details about a specific node for the given NodeBalancer configuration profile.
 *
 * @param nodeBalancerId { number } The ID of the NodeBalancer the config belongs to.
 * @param configId { number } The configuration profile to retrieve nodes for.
 * @param nodeId { number } The Node to be retrieved.
 */


exports.getNodeBalancerConfigNodes = getNodeBalancerConfigNodes;

const getNodeBalancerConfigNode = (nodeBalancerId, configId, nodeId) => (0, _request.default)((0, _request.setMethod)('GET'), (0, _request.setURL)(`${_constants.API_ROOT}/nodebalancers/${nodeBalancerId}/configs/${configId}/nodes/${nodeId}`));
/**
 * createNodeBalancerConfigNode
 *
 * Creates a NodeBalancer Node, a backend that can accept traffic for
 * this NodeBalancer Config. Nodes are routed requests on the configured port based on their status.
 *
 * Note: The Linode API does not accept separate port and IP address parameters. This method will join
 * the IP and port after validation:
 *
 * data: {
 *  address: '0.0.0.0',
 *  port: 80
 * }
 *
 * will become:
 *
 * data: {
 *  address: '0.0.0.0:80'
 * }
 *
 * @param nodeBalancerId { number } The ID of the NodeBalancer the config belongs to.
 * @param configId { number } The configuration profile to add a node to.
 * @param data
 */


exports.getNodeBalancerConfigNode = getNodeBalancerConfigNode;

const createNodeBalancerConfigNode = (nodeBalancerId, configId, data) => (0, _request.default)((0, _request.setMethod)('POST'), (0, _request.setURL)(`${_constants.API_ROOT}/nodebalancers/${nodeBalancerId}/configs/${configId}/nodes`), (0, _request.setData)(data, _nodebalancers.nodeBalancerConfigNodeSchema, _utils.mergeAddressAndPort));
/**
 * createNodeBalancerConfigNode
 *
 * Updates a backend node for the specified NodeBalancer configuration profile.
 *
 * Note: The Linode API does not accept separate port and IP address parameters. This method will join
 * the IP and port after validation:
 *
 * data: {
 *  address: '0.0.0.0',
 *  port: 80
 * }
 *
 * will become:
 *
 * data: {
 *  address: '0.0.0.0:80'
 * }
 *
 * @param nodeBalancerId { number } The ID of the NodeBalancer the config belongs to.
 * @param configId { number } The configuration profile to add a node to.
 * @param data
 */


exports.createNodeBalancerConfigNode = createNodeBalancerConfigNode;

const updateNodeBalancerConfigNode = (nodeBalancerId, configId, nodeId, data) => (0, _request.default)((0, _request.setMethod)('PUT'), (0, _request.setURL)(`${_constants.API_ROOT}/nodebalancers/${nodeBalancerId}/configs/${configId}/nodes/${nodeId}`), (0, _request.setData)(data, _nodebalancers.nodeBalancerConfigNodeSchema, _utils.mergeAddressAndPort));
/**
 * deleteNodeBalancerConfigNode
 *
 * Deletes a single backend Node form the specified NodeBalancer configuration profile.
 *
 * @param nodeBalancerId { number } The ID of the NodeBalancer the config belongs to.
 * @param configId { number } The configuration profile to delete a node from.
 * @param nodeId { number} The node to be deleted.
 */


exports.updateNodeBalancerConfigNode = updateNodeBalancerConfigNode;

const deleteNodeBalancerConfigNode = (nodeBalancerId, configId, nodeId) => (0, _request.default)((0, _request.setMethod)('DELETE'), (0, _request.setURL)(`${_constants.API_ROOT}/nodebalancers/${nodeBalancerId}/configs/${configId}/nodes/${nodeId}`));

exports.deleteNodeBalancerConfigNode = deleteNodeBalancerConfigNode;