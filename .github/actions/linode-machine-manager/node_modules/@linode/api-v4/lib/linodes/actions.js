"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scheduleOrQueueMigration = exports.startMutation = exports.cloneLinode = exports.rescueMetalLinode = exports.rescueLinode = exports.rebuildLinode = exports.resizeLinode = exports.linodeShutdown = exports.linodeReboot = exports.linodeBoot = void 0;

var _linodes = require("@linode/validation/lib/linodes.schema");

var _constants = require("../constants");

var _request = _interopRequireWildcard(require("../request"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * linodeBoot
 *
 * Boots a Linode you have permission to modify.
 * If no parameters are given, a Config profile will be
 * chosen for this boot based on the following criteria:
 * - If there is only one Config profile for this Linode, it will be used.
 * - If there is more than one Config profile, the last booted config will be used.
 * - If there is more than one Config profile and none were the last to be booted
 *  (because the Linode was never booted or the last booted config was deleted)
 *  an error will be returned.
 *
 * @param linodeId { number } The id of the Linode to boot.
 * @param config_id { number } the ID of the configuration profile to boot from.
 */
const linodeBoot = (linodeId, config_id) => (0, _request.default)((0, _request.setURL)(`${_constants.API_ROOT}/linode/instances/${linodeId}/boot`), (0, _request.setMethod)('POST'), (0, _request.setData)({
  config_id
}));
/**
 * linodeReboot
 *
 * Reboots a Linode you have permission to modify.
 * If any actions are currently running or queued,
 * those actions must be completed first before you can initiate a reboot.
 *
 * @param linodeId { number } The id of the Linode to reboot.
 * @param config_id { number } the ID of the configuration profile to boot from.
 */


exports.linodeBoot = linodeBoot;

const linodeReboot = (linodeId, config_id) => (0, _request.default)((0, _request.setURL)(`${_constants.API_ROOT}/linode/instances/${linodeId}/reboot`), (0, _request.setMethod)('POST'), (0, _request.setData)({
  config_id
}));
/**
 * linodeShutdown
 *
 * Shuts down a Linode you have permission to modify.
 * If any actions are currently running or queued,
 * those actions must be completed first before you can initiate a shutdown.
 *
 * @param linodeId { number } The id of the Linode to shut down.
 */


exports.linodeReboot = linodeReboot;

const linodeShutdown = linodeId => (0, _request.default)((0, _request.setURL)(`${_constants.API_ROOT}/linode/instances/${linodeId}/shutdown`), (0, _request.setMethod)('POST'));
/**
 * resizeLinode
 *
 * Resizes a Linode to a different Type. You must have read_write
 * permission on the target Linode to use this endpoint. If resizing
 * to a smaller Type, the Linode must not have more disk allocation
 * than the new Type allows.
 *
 * @param linodeId { number } The id of the Linode to resize.
 * @param type { string } the new size of the Linode
 * @param auto_resize_linode { boolean } do you want to resize your disks after
 * the Linode is resized? NOTE: Unless the user has 1 ext disk or 1 ext disk and
 * 1 swap disk, this flag does nothing, regardless of whether it's true or false
 */


exports.linodeShutdown = linodeShutdown;

const resizeLinode = (linodeId, type, allow_auto_disk_resize = true) => (0, _request.default)((0, _request.setURL)(`${_constants.API_ROOT}/linode/instances/${linodeId}/resize`), (0, _request.setMethod)('POST'), (0, _request.setData)({
  type,
  allow_auto_disk_resize
}));
/**
 * rebuildLinode
 *
 * Rebuilds a Linode you have permission to modify.
 * A rebuild will first shut down the Linode,
 * delete all disks and configs on the Linode,
 * and then deploy a new image to the Linode with the given attributes.
 *
 * @param linodeId { number } The id of the Linode to rebuild.
 * @param data { object }
 * @param data.image { string } the image to be deployed during rebuild.
 * @param data.root_pass { string } the new root password for the default Linode disk
 * @param data.authorized_users { Array(string) } A list of usernames that will have their SSH keys, if any,
 * automatically appended to the root user's authorized keys file.
 */


exports.resizeLinode = resizeLinode;

const rebuildLinode = (linodeId, data) => (0, _request.default)((0, _request.setURL)(`${_constants.API_ROOT}/linode/instances/${linodeId}/rebuild`), (0, _request.setMethod)('POST'), (0, _request.setData)(data, _linodes.RebuildLinodeSchema));
/**
 * rescueLinode
 *
 * Boots the Linode into Rescue Mode, a safe environment
 * for performing many system recovery and disk management tasks.
 * Rescue Mode is based on the Finnix recovery distribution, a self-contained
 * and bootable Linux distribution. You can also use Rescue Mode for tasks
 * other than disaster recovery, such as formatting disks to use different
 * filesystems, copying data between disks, and downloading files from a
 * disk via SSH and SFTP.
 *
 * @param linodeId { number } The id of the Linode to boot into rescue mode.
 * @param devices { object } device assignments to be used in rescue mode.
 */


exports.rebuildLinode = rebuildLinode;

const rescueLinode = (linodeId, devices) => {
  const _devices = _objectSpread({}, devices);

  delete _devices['sdh'];
  return (0, _request.default)((0, _request.setURL)(`${_constants.API_ROOT}/linode/instances/${linodeId}/rescue`), (0, _request.setMethod)('POST'), (0, _request.setData)({
    devices: _devices
  }));
};
/**
 * rescueMetalLinode
 *
 * Boots a Bare Metal Linode into Rescue Mode, a safe environment
 * for performing many system recovery and disk management tasks.
 * Rescue Mode is based on the Finnix recovery distribution, a self-contained
 * and bootable Linux distribution.
 *
 * Bare Metal Linodes have a different rescue flow, since their disks are not
 * managed through the Linode API. This method hits the same endpoint as rescueLinode,
 * but does not accept an array of devices.
 *
 * @param linodeId { number } The id of the Linode to boot into rescue mode.
 */


exports.rescueLinode = rescueLinode;

const rescueMetalLinode = linodeId => (0, _request.default)((0, _request.setURL)(`${_constants.API_ROOT}/linode/instances/${linodeId}/rescue`), (0, _request.setMethod)('POST'));
/**
 * cloneLinode
 *
 * You can clone your Linode's existing Disks or Configuration profiles to another
 * Linode on your Account. In order for this request to complete successfully,
 * your User must have the add_linodes grant. Cloning to a new Linode will
 * incur a charge on your Account. If cloning to an existing Linode, any actions
 * currently running or queued must be completed first before you can clone to it.
 *
 * @param linodeId { number } The id of the Linode to be cloned.
 */


exports.rescueMetalLinode = rescueMetalLinode;

const cloneLinode = (sourceLinodeId, data) => {
  return (0, _request.default)((0, _request.setURL)(`${_constants.API_ROOT}/linode/instances/${sourceLinodeId}/clone`), (0, _request.setMethod)('POST'), (0, _request.setData)(data));
};
/**
 * startMutation
 *
 * Linodes created with now-deprecated Types are entitled to a free upgrade
 * to the next generation. A mutating Linode will be allocated any new resources
 * the upgraded Type provides, and will be subsequently restarted if it was currently running.
 * If any actions are currently running or queued, those actions must be completed
 * first before you can initiate a mutate.
 *
 * @param linodeId { number } The id of the Linode to be upgraded.
 */


exports.cloneLinode = cloneLinode;

const startMutation = linodeID => {
  return (0, _request.default)((0, _request.setURL)(`${_constants.API_ROOT}/linode/instances/${linodeID}/mutate`), (0, _request.setMethod)('POST'));
};
/**
 * scheduleOrQueueMigration
 *
 * Schedules a pending migration (if one is present on the Linode),
 * or immediately moves a scheduled migration into the migration queue.
 *
 * @param linodeId { number } The id of the Linode to be migrated.
 */


exports.startMutation = startMutation;

const scheduleOrQueueMigration = (linodeID, payload) => (0, _request.default)((0, _request.setURL)(`${_constants.API_ROOT}/linode/instances/${linodeID}/migrate`), (0, _request.setData)(payload || {}), (0, _request.setMethod)('POST'));

exports.scheduleOrQueueMigration = scheduleOrQueueMigration;