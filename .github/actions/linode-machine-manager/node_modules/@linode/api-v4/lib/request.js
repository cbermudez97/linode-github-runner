"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CancellableRequest = exports.mockAPIError = exports.requestGenerator = exports.setXFilter = exports.setData = exports.setHeaders = exports.setParams = exports.setMethod = exports.setURL = exports.isEmpty = exports.setToken = exports.baseRequest = void 0;

var _axios = _interopRequireDefault(require("axios"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const baseRequest = _axios.default.create({
  baseURL: 'https://api.linode.com/v4'
});
/**
 * setToken
 *
 * Helper function to authenticate your requests. Most Linode APIv4 endpoints
 * require an OAuth token or personal access token (PAT) to authenticate.
 *
 * @param token
 */


exports.baseRequest = baseRequest;

const setToken = token => {
  return baseRequest.interceptors.request.use(config => {
    return _objectSpread(_objectSpread({}, config), {}, {
      headers: _objectSpread(_objectSpread({}, config.headers), {}, {
        Authorization: `Bearer ${token}`
      })
    });
  });
};

exports.setToken = setToken;

const set = (field, value) => object => {
  return !isEmpty(value) ? _objectSpread(_objectSpread({}, object), {}, {
    [field]: value
  }) : object;
};

const isEmpty = v => v === undefined || v === null || v.length === 0 || typeof v === 'object' && Object.keys(v).length === 0 && v.constructor === Object;
/** URL */


exports.isEmpty = isEmpty;

const setURL = url => set('url', url);
/** METHOD */


exports.setURL = setURL;

const setMethod = method => set('method', method);
/** Param */


exports.setMethod = setMethod;

const setParams = (params = {}) => set('params', params);

exports.setParams = setParams;

const setHeaders = (newHeaders = {}) => object => {
  return !isEmpty(newHeaders) ? _objectSpread(_objectSpread({}, object), {}, {
    headers: _objectSpread(_objectSpread({}, object.headers), newHeaders)
  }) : object;
};
/**
 * Validate and set data in the request configuration object.
 */


exports.setHeaders = setHeaders;

const setData = (data, schema, postValidationTransform) => {
  if (!schema) {
    return set('data', data);
  }

  const updatedData = typeof postValidationTransform === 'function' ? postValidationTransform(data) : data;

  try {
    schema.validateSync(data, {
      abortEarly: false
    });
    return set('data', updatedData);
  } catch (error) {
    return object => _objectSpread(_objectSpread({}, object), {}, {
      data: updatedData,
      validationErrors: convertYupToLinodeErrors(error)
    });
  }
};
/**
 * Attempt to convert a Yup error to our pattern. The only magic here is the recursive call
 * to itself since we have nested structures (think NodeBalancers).
 */


exports.setData = setData;

const convertYupToLinodeErrors = validationError => {
  const {
    inner
  } = validationError;
  /** If aggregate errors */

  if (inner && inner.length > 0) {
    return inner.reduce((result, innerValidationError) => {
      const err = convertYupToLinodeErrors(innerValidationError);
      return Array.isArray(err) ? [...result, ...err] : [...result, err];
    }, []);
  }
  /** If single error.  */


  return [mapYupToLinodeAPIError(validationError)];
};

const mapYupToLinodeAPIError = ({
  message,
  path
}) => _objectSpread({
  reason: message
}, path && {
  field: path
});
/** X-Filter */


const setXFilter = xFilter => {
  return object => !isEmpty(xFilter) ? _objectSpread(_objectSpread({}, object), {}, {
    headers: _objectSpread(_objectSpread({}, object.headers), {}, {
      'X-Filter': JSON.stringify(xFilter)
    })
  }) : object;
};
/**
 * Builds up a config starting from a default object and applying
 * each of the applied functions.
 *
 * URL is defaulted for testing purposes; otherwise all requests will
 * fail unless setURL() is used in the chain.
 *
 * Config is defaulted to an empty object because setHeaders() merges
 * with the existing headers object, unlike all other setters which directly
 * assign the value. If setHeaders() is called and no headers are present, the result
 * is an error.
 * @param fns An array of functions to be applied to the config object.
 */


exports.setXFilter = setXFilter;

const reduceRequestConfig = (...fns) => fns.reduceRight((result, fn) => fn(result), {
  url: 'https://api.linode.com/v4',
  headers: {}
});
/** Generator */


const requestGenerator = (...fns) => {
  const config = reduceRequestConfig(...fns);

  if (config.validationErrors) {
    return Promise.reject(config.validationErrors // All failed requests, client or server errors, should be APIError[]
    );
  }

  return baseRequest(config).then(response => response.data);
  /*
   * If in the future, we want to hook into every single
   * async action for the purpose of sending the request data
   * to Google Tag Manager, we can uncomment out the following
   * .then() and .catch() on return Axios(config)
   */
  // .then(response => {
  //   /*
  //    * This is sending an event to the Google Tag Manager
  //    * data layer. This is important because it lets us track
  //    * async actions as custom events
  //    */
  //   if ((window as any).dataLayer) {
  //     (window as any).dataLayer = (window as any).dataLayer || [];
  //     (window as any).dataLayer.push({
  //       'event': 'asyncActionSuccess',
  //       'url': response.config.url,
  //       'method': response.config.method,
  //     });
  //   };
  //   return response;
  // })
  // .catch(e => {
  //   /*
  //    * This is sending an event to the Google Tag Manager
  //    * data layer. This is important because it lets us track
  //    * async actions as custom events
  //    */
  //   if ((window as any).dataLayer) {
  //     (window as any).dataLayer = (window as any).dataLayer || [];
  //     (window as any).dataLayer.push({
  //       'event': 'asyncActionFailure',
  //       'url': e.response.config.url,
  //       'method': e.response.config.method,
  //     });
  //   };
  //   return Promise.reject(e);
  // });
};
/**
 * Mock Error Function
 *
 * Use this function in place of your API request to mock errors. This returns the same
 * same response body as an Axios error.
 *
 * @example getLinodes = () => mockAPIError();
 * @example getLinode = () => mockAPIError(404, 'Not Found');
 * @example getLinodes = () => mockAPIError(404, 'Not Found');
 */


exports.requestGenerator = requestGenerator;

const mockAPIError = (status = 400, statusText = 'Internal Server Error', data = {}) => new Promise((resolve, reject) => setTimeout(() => reject(createError(`Request failed with a status of ${status}`, {
  data,
  status,
  statusText,
  headers: {},
  config: {}
})), process.env.NODE_ENV === 'test' ? 0 : 250));

exports.mockAPIError = mockAPIError;

const createError = (message, response) => {
  const error = new Error(message);
  error.response = response;
  return error;
};

const CancellableRequest = (...fns) => {
  const config = reduceRequestConfig(...fns);

  const source = _axios.default.CancelToken.source();

  if (config.validationErrors) {
    return {
      cancel: () => null,
      request: () => Promise.reject({
        config: _objectSpread(_objectSpread({}, config), {}, {
          validationErrors: undefined
        }),
        response: {
          data: {
            errors: config.validationErrors
          }
        }
      })
    };
  }

  return {
    cancel: source.cancel,
    request: () => baseRequest(_objectSpread(_objectSpread({}, config), {}, {
      cancelToken: source.token
    })).then(response => response.data)
  };
};

exports.CancellableRequest = CancellableRequest;
var _default = requestGenerator;
exports.default = _default;