"use strict";

var _axiosMockAdapter = _interopRequireDefault(require("axios-mock-adapter"));

var _yup = require("yup");

var _request = _interopRequireWildcard(require("./request"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TEST_URL = 'https://www.example.com';
const mock = new _axiosMockAdapter.default(_request.baseRequest);
mock.onAny().reply(200, {
  data: {}
});
beforeEach(() => {
  mock.resetHistory();
  jest.clearAllMocks();
});
describe('Linode JS SDK', () => {
  describe('Base request and helper methods', () => {
    describe('setURL', () => {
      it('should set the specified URL', async () => {
        await (0, _request.default)((0, _request.setURL)(TEST_URL));
        expect(mock.history.get[0].url).toMatch(TEST_URL);
      });
    });
    describe('setMethod', () => {
      it('should create a GET request', async () => {
        await (0, _request.default)((0, _request.setMethod)('GET'));
        expect(mock.history.get).toHaveLength(1);
      });
      it('should create a POST request', async () => {
        await (0, _request.default)((0, _request.setMethod)('POST'));
        expect(mock.history.post).toHaveLength(1);
      });
    });
    describe('setHeaders', () => {
      it('should add a header', async () => {
        const contentType = 'application/x-www-form-urlencoded;charset=utf-8';
        await (0, _request.default)((0, _request.setHeaders)({
          'Content-Type': contentType
        }));
        expect(mock.history.get[0].headers).toHaveProperty('Content-Type', contentType);
      });
    });
    describe('setXFilter', () => {
      it('should add a header', async () => {
        const filter = {
          label: 'my-linode'
        };
        await (0, _request.default)((0, _request.setXFilter)(filter));
        expect(mock.history.get[0].headers).toHaveProperty('X-Filter', JSON.stringify(filter));
      });
      it('should handle nested filters', async () => {
        const filter = {
          '+or': [{
            vcpus: 1
          }, {
            class: 'standard'
          }]
        };
        await (0, _request.default)((0, _request.setXFilter)(filter));
        expect(mock.history.get[0].headers).toHaveProperty('X-Filter', JSON.stringify(filter));
      });
    });
    describe('setParams', () => {
      it('should set URL params', async () => {
        const params = {
          page: 1,
          page_size: 25
        };
        await (0, _request.default)((0, _request.setParams)(params));
        expect(mock.history.get[0].params).toEqual(params);
      });
    });
    describe('setData', () => {
      it('should set provided data as the request body', async () => {
        const data = {
          label: 'my-linode',
          type: 'standard-g6-1'
        };
        await (0, _request.default)((0, _request.setData)(data));
        expect(mock.history.get[0].data).toEqual(JSON.stringify(data));
      });
    });
    describe('Composing constructor functions', () => {
      it('should apply method, data, params, filters, and headers to the final request', async () => {
        const headers = 'application/json';
        const params = {
          page: 1,
          page_size: 1
        };
        const data = {
          size: 10
        };
        const filter = {
          size: {
            '+gte': 6
          }
        };
        await (0, _request.default)((0, _request.setURL)(TEST_URL), (0, _request.setMethod)('POST'), (0, _request.setHeaders)({
          'Content-Type': headers
        }), (0, _request.setXFilter)(filter), (0, _request.setParams)(params), (0, _request.setData)(data));
        const response = mock.history.post[0];
        expect(response).toBeDefined();
        expect(response).toHaveProperty('url', TEST_URL);
        expect(response).toHaveProperty('data', JSON.stringify(data));
        expect(response.headers).toHaveProperty('Content-Type', headers);
        expect(response).toHaveProperty('params', params);
        expect(response.headers).toHaveProperty('X-Filter', JSON.stringify(filter));
      });
    });
  });
  describe('Yup client validation', () => {
    const testSchema = (0, _yup.object)({
      name: (0, _yup.string)().required('This is required!')
    });
    const spy = jest.spyOn(testSchema, 'validateSync');
    it('should validate the schema before submitting a request', async () => {
      await (0, _request.default)((0, _request.setData)({
        name: 'valid-name'
      }, testSchema));
      expect(spy).toHaveBeenCalledTimes(1);
      expect(mock.history.get).toHaveLength(1);
    });
    it('should return schema errors as an array of Linode API errors without submitting a request', async () => {
      await (0, _request.default)((0, _request.setData)({}, testSchema)).catch(error => {
        expect(error).toEqual([{
          field: 'name',
          reason: 'This is required!'
        }]);
        expect(spy).toHaveBeenCalledTimes(1);
        expect(mock.history.get).toHaveLength(0);
      });
    });
  });
  describe('Helpers', () => {
    describe('isEmpty', () => {
      it('returns true for undefined and null', () => {
        expect((0, _request.isEmpty)(undefined)).toBe(true);
        expect((0, _request.isEmpty)(null)).toBe(true);
      });
      it('returns true for an empty array', () => {
        expect((0, _request.isEmpty)([])).toBe(true);
      });
      it('returns true for an empty object', () => {
        expect((0, _request.isEmpty)({})).toBe(true);
      });
      it('returns true for an empty string', () => {
        expect((0, _request.isEmpty)('')).toBe(true);
      });
      it('returns false for non-empty objects', () => {
        expect((0, _request.isEmpty)(1)).toBe(false);
        expect((0, _request.isEmpty)('five')).toBe(false);
        expect((0, _request.isEmpty)([undefined, undefined, undefined])).toBe(false);
        expect((0, _request.isEmpty)({
          fruits: ['apple', 'orange']
        })).toBe(false);
        expect((0, _request.isEmpty)(new Date())).toBe(false);
      });
    });
  });
});